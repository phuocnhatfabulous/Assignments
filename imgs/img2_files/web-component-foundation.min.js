if (window.cdc === undefined) { window.cdc = {}; }
if (cdc.wcUtil === undefined) {
    /**
     * Web component utility library that helps bridge the gap for javascript that needs to be written in both a web component context as well as a non-webcomponent use case
     * Descriptions for API methods outlined described for each corresponding function definition
     * @return {Object} {
     *     {Function} getMethod
     *     {Function} getObj
     * }
     */
    cdc.wcUtil = (() => {
        /**
         * Used to retrieve method from specified element (in web component name format) either from the web component it's registered to or from the element methods array
         * @param  {String}   element      name of component (i.e. cdc-masthead, cdc-nav, search, etc.)
         * @param  {String}   methodName   name of method requested
         * @return {Function}              pointer of method desired
         */
        let getMethod = (element, methodName) => {
            // convert element tag into camel case
            let cdcElement = element.split('-');
            for (let i = 1; i < cdcElement.length; i++) { cdcElement[i] = cdcElement[i].charAt(0).toUpperCase() + cdcElement[i].slice(1); }
            cdcElement = cdcElement.join('');
            // if the window has a camel case object of the input element, then the web component is being utilized
            // otherwise, reference to the cdc object
            if (window.hasOwnProperty(cdcElement) || window.hasOwnProperty(cdcElement+'Sat')) {
                return window.hasOwnProperty(cdcElement) ? document.querySelector(element)[methodName] : document.querySelector(element+'-sat')[methodName];
            } else if (cdc.hasOwnProperty(cdcElement)) {
                for (let method in cdc[cdcElement].methods) {
                    if (cdc[cdcElement].methods.hasOwnProperty(method)) {
                        if (cdc[cdcElement].methods[method].key === methodName) {
                            return cdc[cdcElement].methods[method].value;
                        }
                    }
                }
                return (() => {});
            } else {
                throw new TypeError("cdc.wcUtil.getMethod cannot find " + methodName + " in " + element);
            }
        };

        /**
         * Used to retrieve object from DOM based on specified elementName whether it is present as a web component or a standard DOM element - equivalent to using document.querySelector
         * @param  {String}  elementName       name of DOM element desired
         * @param  {Object}  relativeTo        [Optional] object to start parsing the DOM from 
         * @param  {Boolean} onlyCustomElement [Optional] set to true if you only want to retrieve web component and do not want the shadowDom of web component
         * @return {Object}                    DOM object of specified element
         */
        let getObj = (elementName, relativeTo, onlyCustomElement) => {
            let element;
            relativeTo = relativeTo || document.querySelector('cec-template') || document.querySelector('cdc-template-micro') || document.querySelector('cdc-template') || document;
            element = relativeTo.querySelector('cec-' + elementName + '-sat') || relativeTo.querySelector('cdc-' + elementName + '-sat') || relativeTo.querySelector('cec-' + elementName) ||relativeTo.querySelector('cdc-' + elementName) || relativeTo;
            if (!onlyCustomElement) {
                if (!!element.shadowRoot) { element = element.shadowRoot; }
                element = element.querySelector('#fwt-' + elementName) || element.querySelector('#fw-' + elementName) || element;
            }
            return element;
        };

        return {
            getMethod: getMethod,
            getObj: getObj
        };
    })();
}

if (window.cdc === undefined) { window.cdc = {}; }
if (window.cdc.wcAncillaryAssetAllocator === undefined) {
    /**
     * Polyfill for IE 11 to support .includes method on Objects
     */
    if (!String.prototype.includes) {
        Object.defineProperty(String.prototype, 'includes', {
            value: function (search, start) {
                if (typeof start !== 'number') { start = 0; }
                if (start + search.length > this.length) {
                    return false;
                } else {
                    return this.indexOf(search, start) !== -1;
                }
            }
        });
    }
    /**
     * wcAncillaryAssetAllocator is purpose-built to load all necessary assets required for web components as well as specified localized web components 
     * @return {Object} {
     *     {Function}  init  used to initialize specified web components with desired configuration
     * }
     */
    cdc.wcAncillaryAssetAllocator = (function () {
        var ua = window.navigator.userAgent,
            assets = [],
            i, j;

        /**
         * Creates next asset object in assets array
         * @return {Object} {
         *     {String} location: relative url of required asset,
         *     {Boolean} wca: set to true if asset is a web component asset
         * }
         */
        var nextAsset = function () { return assets[assets.length] = {location: "", name: "", localePath: false, wca: false}; };

        /**
         * Minimum required assets needed for web component architecture added to assets array
         * @param {Boolean} isWem specifies if assets are being loaded on a WEM environment
         */
        var addMinimumDependencies = function (isWem) {
            if (!isWem) {
                i = nextAsset();
                i.type = "link";
                i.location = "/etc/designs/cdc/clientlibs/responsive/css/cisco-sans.min.css";
            }

            if (ua.indexOf('Trident') === -1) {
                i = nextAsset();
                i.type = "script";
                i.location = "/etc/designs/cdc/fw/lib/webcomponents/custom-elements-es5-adapter.js";
            }

            i = nextAsset();
            i.type = "script";
            i.location = "/etc/designs/cdc/fw/lib/webcomponents/webcomponents-loader.js";

            i = nextAsset();
            i.type = "script";
            i.location = "/etc/designs/cdc/fw/lib/polymer/polymer-init.js";

            // for some reason, this asset won't load completely if left as relative path but only in Chrome
            i = nextAsset();
            i.type = "link";
            i.location = "/etc/designs/cdc/fw/lib/polymer/polymer-element.html";
            
            i = nextAsset();
            i.type = "link";
            i.location = "/etc/designs/cdc/fw/lib/polymer/lib/utils/import-href.html";
        };

        /**
         * Adds targetter bundle to assets array
         */
        var addTargetter = function () {
            i = nextAsset();
            i.type = "script";
            i.location = "/c/dam/cdc/j/targeter-bundle_min.js";
        };

        /**
         * Adds specified web components to assets array
         * @param {Array} wcAssets array of strings that correlate to the names web components or array of objects containing asset name and corresponding locale/path
         * @param {String} localePath    specifies where web component should be retrived from
         */
        var addWCAssets = function (wcAssets, localePath) {
            for (j = 0; j < wcAssets.length; j++) {
                if(cdc.isRei && wcAssets[j]=="cdc-nav"){
                    wcAssets[j]="cdcr-nav";
                }else if(wcAssets[j]=="cdcr-template" && !cdc.isRei){
                    wcAssets[j]="cdc-template";
                }                
                i = nextAsset();
                i.name = (localePath === false ? wcAssets[j].name : wcAssets[j]);
                i.localePath = (localePath === false ? wcAssets[j].localePath : localePath);
                i.wca = true;
            }
        };

        /**
         * Setup assets in assets array to be included in the page based on file extension
         * @param  {Boolean} isRelative specifies if full asset path(s) should be relative (i.e. localhost, dev environments)
         * @param  {String}  env        specifies what environment to append to relative path (not used if isRelative is true)
         */
        var setupAssets = function (isRelative, env) {
            var debug = location.search.slice(1).includes('debugWCAssets') || false;
            function pathConstructor(relativePath) { return (debug ? '' : 'https://' + instances[env] + domain) + relativePath; }

            var asset,
                loc,
                wcrAssets = [],
                instances = {
                    dev: 'fdk-devint',
                    stage: 'fdk-stage',
                    pstage: 'fdk-pstage',
                    prod: 'www'
                },
                domain = '.cisco.com';

            if (env === 'unknown') { env = 'prod'; }
            for (j = 0; j < assets.length; j++) {
                if (assets[j].location.match(/.*?\.js$/) || assets[j].location.match(/.*?\.css$/)) {
                    var loc = "href";
                    if (!isRelative) { assets[j].location = pathConstructor(assets[j].location); }
                    if (assets[j].location.match(/.*?\.js$/)) {
                        asset = document.createElement('script');
                        loc = 'src';
                        asset.setAttribute('type', 'text/javascript');
                    } else {
                        asset = document.createElement('link');
                        asset.setAttribute('rel', 'stylesheet');
                    }
                    asset.setAttribute(loc, assets[j].location);
                    document.head.appendChild(asset);
                } else {
                    if (assets[j].wca) {
                        assets[j].location = '/c/' + assets[j].localePath + '/web-component/' + (assets[j].name.indexOf('template') !== -1 ? 'templates/' : '') + assets[j].name + '.html' + (env === 'dev' || location.search.slice(1).includes('wcmmode=disabled') ? '?wcmmode=disabled' : '');
                    }
                    if (!isRelative || !assets[j].wca) { assets[j].location = pathConstructor(assets[j].location); }
                    asset = document.createElement('link');
                    asset.setAttribute('href', assets[j].location);
                    asset.setAttribute('rel', 'import');
                    if (assets[j].name.indexOf('nav') !== -1 || assets[j].name.indexOf('search') !== -1) { asset.setAttribute('async',''); }
                    wcrAssets.push(asset);
                }
            }

            if (wcrAssets.length > 0) {
                document.addEventListener('WebComponentsReady', function () {
                    for (j = 0; j < wcrAssets.length; j++) { document.head.appendChild(wcrAssets[j]); }

                    // implemented as a temporary solution for search release not aligned to WEM release
                    if (typeof cdcSearchNew !== "undefined" && cdcSearchNew) {
                        let link = document.createElement('link');
                        link.setAttribute('href', pathConstructor("/c/dam/cdc/web-component/cdc-search/cdc-search.html"));
                        link.setAttribute('rel', 'import');
                        document.head.appendChild(link);
                    }
                });
            }
        };

        /**
         * Invokes appropriate private methods based on input parameters based on needs of web component architecture
         * @param  {Array}    wcAssets       array of strings that correlate to the names of web components or array of objects containing asset name and corresponding locale/path
         * @param  {String}   localePath     specifies where web component should be retrieved from (expected format: en/us or en_au for all other locales); false if wcAssets, is array of objects
         * @param  {Boolean}  isWem          [Optional] specifies if assets are being loaded on a WEM environment
         * @param  {Boolean}  needTargetter  [Optional] specifies need for targetter bundle to be loaded (generally needed on external sites)
         * @param  {Boolean}  isRelative     [Optional] specifies if asset path(s) should be relative
         * @param  {String}   env            [Optional] specifies enviornment to append to relative path (should not be used with isRelative)
         * @param  {Boolean}  hasEnvOverride [Optional] specifies if environment needs to be overridden (should be used with env)
         */
        var init = function (wcAssets, localePath, isWem, needTargetter, isRelative, env, hasEnvOverride) {
            isWem = isWem || false;
            needTargetter = needTargetter || false;
            isRelative = isRelative || false;
            env = env || 'prod';

            if (ua.indexOf('MSIE') === -1) {
                if (hasEnvOverride) {
                    if (window.cdcext === undefined) { window.cdcext = {}; }
                    cdcext.customEnvironment = env;
                }

                if (needTargetter) { addTargetter(); }
                addMinimumDependencies(isWem);
                addWCAssets(wcAssets, localePath);
                setupAssets(isRelative, env);
            }
        };

        return {
            init: init
        };
    }());
}

if (window.cdc === undefined) { window.cdc = {}; }
if (cdc.cdcGeneric === undefined) { cdc.cdcGeneric = {}; }

cdc.cdcGeneric.methods = [{
    key: 'getObj',
    /**
     * Equivalent of document.getElementById but written in a shadowDom context
     * @param  {String} target CSS selector for desired element
     * @return {Object}        DOM Object of specified CSS selector
     */
    value: function getObj(id) {
        var obj = this.shadowRoot;
        if (id !== null) { obj = obj.getElementById(id); }
        return obj;
    }
}, {
    key: 'getObjBySelector',
    /**
     * Equivalent of document.querySelector but written in a shadowDom context
     * @param  {String} target CSS selector for desired element
     * @return {Object}        DOM Object of specified CSS selector
     */
    value: function getObjBySelector(target) {
        var obj = this.shadowRoot;
        if (target !== null) { obj = obj.querySelector(target); }
        return obj;
    }
}, {
    key: 'getObjBySelectorAll',
    /**
     * Equivalent of document.querySelectorAll but written in a shadowDom context
     * @param  {String} target  CSS selector for desired element
     * @param  {String} element (Optional) element to start relative to
     * @return {Object}         DOM Object of specified CSS selector
     */
    value: function getObjBySelectorAll(target, element) {
        element = element || this.shadowRoot;
        if (target !== null) { element = element.querySelectorAll(target); }
        return element;
    }
}, {
    key: 'mq',
    /**
     * Media query check adapted from modernizr.js
     * @param  {String}  mq media query string
     * @return {Boolean}    returns true if screen size matches current media query
     */
    value: function mq(mq) {
        var matchMedia = window.matchMedia || window.msMatchMedia;
        if (matchMedia) {
            var mql = matchMedia(mq);
            return mql && mql.matches || false;
        } else { return false; }
    }
}];

cdc.cdcGeneric.properties = {

    shortBreakpoint: {
        type: String,
        value: '(min-width: 0px)'
    },
    mediumBreakpoint: {
        type: String,
        value: '(min-width: 768px)'
    },
    grandeBreakpoint: {
        type: String,
        value: '(min-width: 1024px)'
    },
    ventiBreakpoint: {
        type: String,
        value: '(min-width: 1280px)'
    }
};
if (window.cdc === undefined) { window.cdc = {}; }
if (cdc.wcTypeAhead === undefined) { cdc.wcTypeAhead = {}; }

cdc.wcTypeAhead.methods = [{
    key: 'wcSearchPhraseHandler',
    value: function wcSearchPhraseHandler() {
        var me = this,
            searchPhrase = me.$['srch-phrase'];
        searchPhrase.addEventListener('focus', () => {
            me.wcTypeAheadShow(me);
            me.$['srch-form'].classList.add('focus');
        });
        searchPhrase.addEventListener('blur', () => {
            me.wcTypeAheadHide();
            me.$['srch-form'].classList.remove('focus');
        });
        searchPhrase.addEventListener('keyup', (event) => me.wcSearchTypeAheadKeyup(me, event));
        searchPhrase.addEventListener('keydown', (event) => me.typeAheadKeydown(me, event));
    }
}, {
    key: 'wcSearchClearButtonHandler',
    value: function wcSearchClearButtonHandler(me) {
        me.$['srch-phrase'].value = "";
        me.wcHideSearchClearButton(me);
        me.wcTypeAheadHide();
        me.$['srch-typeahead'].innerHTML = "";
        me.typeaheadResults = [];
        me.$['srch-phrase'].focus();
    }
}, {
    key: 'wcHideSearchClearButton',
    value: function wchideSearchClearButton(me) {
        if (me.$['srch-phrase'].value.trim().length === 0) { me.$['srch-clear-btn'].classList.add('hidden'); }
    }
}, {
    key: 'wcMenuKeys',
    value: function wcMenuKeys(event, upArrowCallback, downArrowCallback, leftArrowCallback, rightArrowCallback) {
        if (event && event.keyCode) {
            switch (event.keyCode) {
                case 37: // Arrow left
                    leftArrowCallback(event);
                    break;
                case 38:
                    // Up-arrow
                    event.preventDefault();
                    upArrowCallback(event);
                break;
                case 39: // Arrow right
                    rightArrowCallback(event);
                    break;
                case 40:
                    // Down-arrow
                    event.preventDefault();
                    downArrowCallback(event);
                break;
            }
        }
    }
}, {
    key: 'wcSearchTypeAheadKeydown',
    value: function wcSearchTypeAheadKeydown(event, enterCallback) {
        var me = this,
            searchPhrase = me.$['srch-phrase'],
            form = me.$['srch-form'];

        let tabCallback = () => {
            if (me.index !== -1) { searchPhrase.value = me.typeaheadResults[me.index].submitText; }
            me.wcTypeAheadHide();
        };

        let upArrowCallback = () => {
            if (me.typeaheadResults.length > 0) {
                if (me.index >= 0) {
                    if (me.index === -1 || form.classList.contains('focus')) { form.classList.remove('focus'); }
                    me.mouseIndex = me.index;
                    if (me.index === 0) {
                        me.getObj('tooltip_1').classList.remove('hover');
                        searchPhrase.value = me.initialInputValue;
                    } else { searchPhrase.value = me.typeaheadResults[me.index-1].submitText; }
                    me.wcTypeAheadUpdateResults(me, me.index--, -2);

                    if (me.index === -1 && !form.classList.contains('focus')) { form.classList.add('focus'); }
                } else if (me.index === -1) {
                    form.classList.remove('focus');
                    me.index = me.typeaheadResults.length;
                    searchPhrase.value = me.typeaheadResults[me.index-1].submitText;
                    me.mouseIndex = me.index;
                    me.wcTypeAheadUpdateResults(me, me.index--, -2);
                }
            }
        };

        let downArrowCallback = () => {
            if (me.typeaheadResults.length > 0) {
                if (me.index < me.typeaheadResults.length - 1) {
                    if (me.index === -1 || form.classList.contains('focus')) { form.classList.remove('focus'); }
                    searchPhrase.value = me.typeaheadResults[me.index + 1].submitText;
                    me.mouseIndex = me.index;
                    me.wcTypeAheadUpdateResults(me, me.index++, -2);
                } else if (me.index === me.typeaheadResults.length - 1){
                    me.getObj('tooltip_' + me.index).classList.remove('hover');
                    form.classList.add('focus');
                    searchPhrase.value = me.initialInputValue;
                    me.index = -1;
                } else {
                    me.index = -1;
                    searchPhrase.value = me.typeaheadResults[me.index + 1].submitText;
                    me.mouseIndex = me.index;
                    form.classList.add('focus');
                    me.wcTypeAheadUpdateResults(me, me.index++, -2);
                }
            }
        };

        me.wcTypeAheadKeydown(event, tabCallback, enterCallback, upArrowCallback, downArrowCallback);
    }
}, {
    key: 'wcTypeAheadKeydown',
    value: function wcTypeAheadKeydown(event, tabCallback, enterCallback, upArrowCallback, downArrowCallback) {
        if (event && event.keyCode) {
            switch (event.keyCode) {
                case 9:
                    // Tab
                    tabCallback(event);
                break;
                case 13:
                    // Enter
                    event.preventDefault();
                    event.stopPropagation();
                    enterCallback(event);
                break;
                case 38:
                    // Up-arrow
                    event.preventDefault();
                    upArrowCallback(event);
                break;
                case 40:
                    // Down-arrow
                    downArrowCallback(event);
                break;
            }
        }
    }
}, {
    key: 'wcSearchTypeAheadKeyup',
    value: function wcSearchTypeAheadKeyup(me, event) {
        var me = this;

        let escapeCallback = () => me.wcSearchClearButtonHandler(me);

        let delBackspaceCallback = () => me.wcHideSearchClearButton(me);

        let timeoutCallback = () => me.typeAheadFetchResults(true);

        let defaultCallback = () => me.wcHideSearchClearButton(me);

        let preTimeoutCallback = () => {
            if (me.$['srch-phrase'].value.trim().length > 0) { me.$['srch-clear-btn'].classList.remove('hidden'); }
        };

        me.wcTypeAheadKeyup(event, escapeCallback, delBackspaceCallback, timeoutCallback, preTimeoutCallback, defaultCallback);
    }
}, {
    key: 'wcTypeAheadKeyup',
    value: function wcTypeAheadKeyup(event, escapeCallback, delBackspaceCallback, timeoutCallback, preTimeoutCallback, defaultCallback) {
        preTimeoutCallback = preTimeoutCallback || (() => {});
        defaultCallback = defaultCallback || (() => {});

        if (event && event.keyCode) {
            if (this.timeout) {
                clearTimeout(this.timeout);
                this.timeout = false;
            }

            if (event.ctrlKey || event.altKey) { return; }

            var timeout = 100;
            switch (event.keyCode) {
                //case 9: // Tab
                case 27:
                    // Escape
                    escapeCallback(event);
                    timeoutCallback = () => {};
                    break;
                case 8: // Backspace
                case 46: // Delete
                    timeout = 200;
                    delBackspaceCallback();
                break;
                case 9: // Tab
                case 13: // Enter
                case 16: // Shift
                case 17: // Ctrl
                case 18: // Alt
                case 20: // Caps Lock
                case 33: // Page up
                case 34: // Page down
                case 35: // End
                case 36: // Home
                case 37: // Arrow left
                case 38: // Arrow up
                case 39: // Arrow right
                case 40: // Arrow down
                case 45: // Insert
                    return;
                default:
                    timeout = 100;
                    defaultCallback();
                break;
            }
            this.index = -1;
            preTimeoutCallback();
            this.timeout = setTimeout(() => timeoutCallback(), timeout);
        }
    }
}, {
    key: 'wcTypeAheadMouseHandler',
    value: function wcTypeAheadMouseHandler(event, clickCallback) {
        let me = this,
            searchPhrase = me.$['srch-phrase'],
            index = event.target.id !== "" ? event.target.id : event.target.parentNode.id;
        if (index.indexOf('tooltip') !== -1) {
            index = parseInt(index.substring(index.indexOf('_') + 1));

            let previous = me.index;
            me.index = index;

            if (event.type === 'click') {
                if (me.index >= 0) {
                    // submit the submittext rather than the trucated text
                    searchPhrase.value = me.typeaheadResults[me.index].submitText;
                    clickCallback();
                } else {
                    me.wcTypeAheadHide();
                }
            } else if (event.type === 'mouseover' || event.type === 'mouseout') {
                if (event.type === 'mouseover') {
                    me.mouseIndex = index;
                } else if (event.type === 'mouseout') {
                    me.index = me.mouseIndex;
                }

                me.wcTypeAheadUpdateResults(me, -2, previous);
            }
        }
    }
}, {
    key: 'wcTypeAheadShow',
    value: function wcTypeAheadShow(me) {
        me = me || this;
        if (me.typeaheadResults.length > 0) {
            let searchTypeAhead = me.$['srch-typeahead'];

            me.$['istadisplayed'].value = "true";
            searchTypeAhead.classList.add('visible');

            let searchInstructions = cdc.cdcSearch.Cisco_Search_Instruction_After_Result;
            if (searchInstructions !== undefined && searchInstructions.indexOf('$RESULTSLENGTH$') > 0){
                searchInstructions = searchInstructions.replace("$RESULTSLENGTH$", me.typeaheadResults.length);
                me.$["srch-screenreader-instruction"].innerHTML = searchInstructions;
            }
        } else {
            me.$["srch-screenreader-instruction"].innerHTML = cdc.cdcSearch.Cisco_Search_Autocomplete_Instructions;
            me.wcTypeAheadHide();
        }
    }
}, {
    key: 'wcTypeAheadHide',
    value: function wcTypeAheadHide() {
        let typeAhead = this.$['srch-typeahead'];
        if (typeAhead && typeAhead.classList.contains('visible')) {
            typeAhead.classList.remove('visible');
            this.$['istadisplayed'].value = "false";
        }
    }
}, {
    key: 'wcTypeAheadFetchResults',
    value: function wcTypeAheadFetchResults(typeaheadQueryString, showTypeAhead) {
        var me = this;

        let httpRequest = new XMLHttpRequest();
        httpRequest.onreadystatechange = () => {
            if (httpRequest.readyState == 4 && httpRequest.status == 200) { me.typeAheadContructResultsArray(JSON.parse(httpRequest.responseText), 
            showTypeAhead); }
            else if (httpRequest.status == 400) { me.wcTypeAheadHide(); }
        };

        httpRequest.open("GET", typeaheadQueryString, true);
        httpRequest.send();
    }
}, {
    key: 'wcTypeAheadDisplayResults',
    value: function wcTypeAheadDisplayResults(results, showTypeAhead) {
        let me = this,
            typeAheadContainer = me.$['srch-typeahead'];

        me.typeaheadResults = results;
        if (typeAheadContainer.children.length > 0) { typeAheadContainer.innerHTML = ""; }

        if (results.length === 0) { return; }

        let ul = document.createElement('ul'),
            li = document.createElement('li'),
            hr = document.createElement('hr'),
            div = document.createElement('div'),
            span = document.createElement('span'),
            content, tUl, tLi, tDiv, tSpan,
            prevCat = '',
            tooltipIdx = 0;

        ul.setAttribute('role', 'listbox');
        li.setAttribute('role', 'option');
        li.setAttribute('aria-selected', 'false');
        content = ul.cloneNode(true);
        tUl = ul.cloneNode(true);

        // append current tUL with typeahead results (and category title if applicable) to current tLi object
        let appendTypeaheads = () => {
            tLi = li.cloneNode(true);
            if (prevCat !== '') {
                tDiv = div.cloneNode(true);
                tSpan = span.cloneNode(true);
                tSpan.innerHTML = prevCat;
                tDiv.appendChild(tSpan)
                tDiv.appendChild(hr.cloneNode(true));
                tLi.appendChild(tDiv);
            }
            tLi.appendChild(tUl);
            content.appendChild(tLi);
            tUl = ul.cloneNode(true);
        };

        /**
         * expected data structure
         * result: {
         *  typeaheadid,
         *  category,
         *  categoryvalue,
         *  submitText,
         *  displayString
         *  tooltip
         * }
         */
        results.forEach((result) => {
            if (prevCat !== result.categoryvalue) { appendTypeaheads(); }

            tLi = li.cloneNode(true);
            tLi.id = 'tooltip_' + tooltipIdx;
            tLi.innerHTML = result.displayString;
            tUl.append(tLi);
            prevCat = result.categoryvalue;
            tooltipIdx++;
        });
        // execute appendTypeaheads() after iterator as the last tUL needs to be appended
        appendTypeaheads();
        typeAheadContainer.append(content);

        if (showTypeAhead) { setTimeout(me.wcTypeAheadShow, 0, me); }
    }
}, {
    key: 'wcTypeAheadUpdateResults',
    value: function wcTypeAheadUpdateResults(me, previousIndex, previousMouseIndex) {
        var lastHighlighted,
            currentHighlighted,
            index = me.index,
            mouseIndex = me.mouseIndex;

        if (previousIndex === -2) {
            currentHighlighted = me.getObj("tooltip_" + mouseIndex);
        } else if (previousMouseIndex === -2) {
            currentHighlighted = me.getObj("tooltip_" + index);
        }

        lastHighlighted = me.$['srch-typeahead'].getElementsByClassName('hover');
        if (lastHighlighted.length > 0) {
            lastHighlighted[0].setAttribute("aria-selected", "false");
            lastHighlighted[0].classList.remove('hover');
        }

        if (currentHighlighted) {
            currentHighlighted.classList.add('hover');
            currentHighlighted.setAttribute("aria-selected", "true");
        }
    }
}];

cdc.wcTypeAhead.methods = cdc.wcTypeAhead.methods.concat(cdc.cdcGeneric.methods);

cdc.wcTypeAhead.properties = {
    env: String,
    index: {
        type: Number,
        value: -1
    },
    mouseIndex: {
        type: Number,
        value: -1
    },
    typeaheadResults: {
        type: Array,
        value: []
    },
    timeout: Object
};

// concatenate object properties from generic with wcTypeAhead
cdc.wcTypeAhead.properties = Object.assign(cdc.cdcGeneric.properties, cdc.wcTypeAhead.properties);

